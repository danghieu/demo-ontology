var title="<h3  class=\"title\">A Demography Ontology made of OWL with Protégé, published by Sesame and available through a web front-end made in PHP, XHTM and JavaScript.</h3><p class=\"meta\"></p>";
var abst="<p><strong>Abstract.</strong> This project implements an ontology that represents the population of each municipality belonging to each province in a given year. For each municipality in a given year is stored the amount of population by sex, age and marital status. The ontology was written in OWL using Protégé and manual editing and was published with the Sesame framework. We have therefore been developed (using PHP, XHTML and JavaScript) a web front-end able to query the ontology. The front-end allows you to perform a simple search based on key descriptive fields (simple search), a search based on location using Google map (geo search), a vision of the time evolution of the population (growth) and a free search using the language SPARQL (free search).</p>";
var keywords="<p><strong>Keywords:</strong> Demography, Ontology, OWL, RDF, Protégé, Sesame, PHP.</p>"
var intro="<h4>Introduction</h4><p>The Semantic Web is a mesh of information linked up in such a way as to be easily processable by machines, on a global scale. You can think of it as being an efficient way of representing data on the World Wide Web, or as a globally linked database.</p><p>The Semantic Web is not about links between web pages. The Semantic Web describes the relationships between things (like A is a part of B and Y is a member of Z) and the properties of things (like size, weight, age, and price).</p><p>The Semantic Web is generally built on syntaxes which use URIs to represent data, usually in triples based structures: i.e. many triples of URI data that can be held in databases, or interchanged on the World Wide Web using a set of particular syntaxes developed especially for the task. These syntaxes are called \"Resource Description Framework\" syntaxes.</p><p>Therefore the RDF is a language for describing information and resources on the web. Putting information into RDF files, makes it possible for computer programs (\"web spiders\") to search, discover, pick up, collect, analyze and process information from the web. For example if information about music, cars, tickets, etc. were stored in RDF files, intelligent web applications could collect information from many different sources, combine information, and present it to users in a meaningful way.</p><p>It has taken years to put the pieces together that comprise the Semantic Web, including the standardization of RDF, the W3C release of the Web Ontology Language (OWL), and standardization on SPARQL, which adds querying capabilities to RDF. So with standards and languages in place, we can see Semantic Web technologies being used by early adopters.</p><p>Semantic Web technologies are popular in areas such as research and life sciences where they can help researchers by aggregating data on different medicines and illnesses that have multiple names in different parts of the world. On the Web, Twine is offering a knowledge networking application which has been built with Semantic Web technologies. The Joost online television service also uses Semantic technology on the back-end: here Semantic technology is used to help Joost users to understand the relationships between pieces of content, enabling them to find the types of content they want most. Oracle offers a Semantic Web view of its Oracle Technology Network, called the OTN Semantic Web to name a few of those companies who are implementing Semantic Web technologies.</p><p>About our project, we created an ontology which describes the demographies of Italian municipalities. For each municipality in a given year, the amount of population partitioned by sex, age and marital status is stored in a database.</p>";
var ontology="<h4>Ontology</h4><p>Let's see in details all about our ontology: the schema, the languages and the tools we used to write it, the data sources, etc.</p><h5>Preliminary choices</h5><p>Before starting writing our ontology, we tried to decide what we had to represent exactly. Demography is the science studying in a quantitative way the phenomena pertaining to the state and the evolution of the population. In particular we distinguish two fundamental kinds of demography: the static one and the dynamic one. The first aims to take a picture of the population living in a certain region at a certain time. The latter instead focuses on estimating how population changes over time.</p><p>We decided to start from real data, so at first we looked for what the internet offered about. We found the Istituto Italiano di Statistica (ISTAT) provides on its website <a href=\"http://www.demoistat.it\">www.demoistat.it</a> the most recent official data about population resident in Italian municipalities, coming from surveys performed by registry offices. In particular, the \"resident population\" section contains the number of people resident in all Italian municipalities on 1st January of every year, partitioned by age, sex and marital status. Information is stored in a traditional database you can query by means of a web front-end. Data from each municipality in a given year are also downloadable in cvs (comma-separated value) format. Therefore we decided to go by these data and we created our ontology schema to represent these pieces of information at best.</p><h5>Used tools</h5><p>To create our ontology schema and to insert the basic descriptive pieces of information and the first instances of population, we used Protégé framework (version 4.1.0 build 217). Protégé is a free, open source ontology editor developed at Stanford University. The Protégé platform supports two main ways of modeling ontologies via the Protégé-Frames and Protégé-editors. Protégé ontologies can be exported into a variety of formats including RDF(S), OWL, and XML Schema.</p><p>To insert further instances of population from ISTAT data, we manually edited by means of a textual editor the OWL file generated by Protégé.</p><p>To facilitate this boring operation of converting tabular data collected from ISTAT database to XML strings making up the OWL file, we created a simple Java utility which reads the cvs file got from <a href=\"http://www.demoistat.it\">www.demoistat.it</a> for every municipality in a given year, processes it, and returns the corresponding XML strings which have to be inserted into the OWL file. This utility takes as input more csv files at the same time from the same municipality, so after having got the XML output you can easily insert into the OWL file the data of that municipality just in a single cut-and-paste operation.</p><h5>Ontology structure</h5><p>Our ontology plans the <b>GeographicArea</b> class, which represents a generic geographical area to which the geographical data will relate.</p></p>Any instance of the GeographicArea class has the following DataProperties:<ul><li><i>extends</i>. This property expresses the extent of a geographical area. Its value is expressed in square kilometers.</li><li><i>hasName</i>. This property expresses the name of the geographical area.</li><li><i>isLocated</i>. This property expresses the geographic coordinates of a geographical location. Its values are expressed as a pair of decimals: the first one represents the longitude (positive for East and negative for West), and the second one represents the latitude (positive for Nord and negative for South).</li></ul><p>The Ontology has two subclasses of GeographicArea, each of them represents the concret territorial entity we consider: <b>Province</b> and <b>Municipality</b>. The instances of the Province class will be bound to the ones of the Municipality class through the <i>hasMunicipality</i> ObjectProperty. The instances of the Municipality class instead will be bound to the instances of the Population class through the <i>hasPopulation</i> ObjectProperty. That way implements the hierarchical bond Province &rarr; Municipality typical of Italian geographical partitioning. Therefore for each municipality the hasPopulation bond allows you to bind several instances of population.</p><p>Now let’s see how the Population class allows you to store demographic pieces of information. It has the following DataProperties:</p><ul><li><i>livingInTheYear</i>. This property expresses the year in which the population is living. Its values is expressed as four-digit number.</li><li><i>hasSex</i>. This property expresses the sex of a population. It may assume the following values:<ul><li>Female</li><li>Male</li></ul></li><li><i>hasMaritalStatus</i>. This property expresses the marital status of a population. It may assume the following values:<ul><li>Unmarried</li><li>Married</li><li>Divorced</li><li>Widowed</li></ul></li><li><i>numbers</i>. This property expresses the number of the individuals composing the population, divided and ordered by age. Its value is expressed as a list of integers separated by commas.</li></ul><p>By these properties the Ontology can represent the whole information stored into the ISTAT’s database, working to our advantage by allowing us to perform more powerful and effective queries based on the subject &rarr; predicate &rarr; object bonds and on the SPARQL query language, even from automatic processing tools having not an a priori knowledge about the content of the ontology.</p><h5>Ontology publishing</h5><p>We published our Ontology on a SESAME repository. SESAME is an open source framework for storage, inferencing and querying of RDF data. We used the 2.2.4 version: we installed it on an TOMCAT server just downloading the zip file of SDK from the sourceforge repository, and extracting two files into TOMCAT’s webapps folder: openrdf-workbench.war and openrdf-sesame.war. The first one provides a web front-end which allows you to access the information on SESAME repositories through a browser; the second one provides access to SESAME server by dedicated clients using a specialized prothocol based on HTTP requests.</p><p>We published our Ontology through the web front-end by creating a new repository we named <i>demography</i> and uploading the OWL file containing RDF data.</p>";
var frontend="<h4>Front-End</h4><p>With the aim to allow a more simple interaction with the Ontology even from not-skilled human users, we created a web front-end. We started from what the front-end of ISTAT's website already offers, and we enriched data presentation by means of explicative graphics and by inserting more powerful query features.</p><h5>Used languages and tools</h5><p>Because of dealing with a web front-end, the final language we used to represent information is obviously HTML. In particular, we based on the 1.1 Strict version of XHTML specification. By following this rules, we used HTML only to describe information, whereas we delegated to the CSS language everything dealing with the representation of the information.</p><p>For the whole part of information processing on the tomcat server, such as Ontology querying on SESAME, the language we used was PHP version 5.2.6.</p><p>For the client-side processing, such as editing forms or creating graphics, the language we used was JavaScript.</p><p>As our team is formed by three elements, we relied on a code repository to synchronize our project. In particular, we used the free SVN server provided by Google Code. All the front-end source code can be found at the web address <a href=\"http://code.google.com/p/demo-ontology/\">http://code.google.com/p/demo-ontology/</a>.</p><p>We used the NetBeans IDE 6.9.1 (Build 201007282301) development tool as source code editor and SVN client.</p><h5>Provided features</h5><p>Let's analyse the top-level features which are provided by the front-end, postponing the implementative details which make them possible.</p><p><strong>Simple Search</strong>. This page allows you to query the SESAME repository to get information about population living in a given year in a given geographical area (a specific municipality, or a province, or the whole Italian territory), according to the selected sex and marital status. After having filled the form on the left side of the page, by clicking the \"Start Query\" button a graphic and a table appear: they show the result of user's query. The graphic shows the total amount of people which forms the population partitioned by age. The table shows the amount of people which forms the population partitioned by age, sex and marital status.</p><p><strong>Geo Search</strong>. This page allows you to query the SESAME repository to get information about population living in a given year in a given province or municipality. After having filled the form on the left side of the page, by clicking the \"Show\" button the map shows the selected province with a markerplace located on the selected municipality. By clicking it, a window containing a summary of the municipal demographic information appears.</p><p><strong>Growth</strong>. This page allows you to query the SESAME repository to get information about the growth of the population in a given municipality in a given period of time. After having filled the form on the left side of the page, a graphic appears showing the total amount of population living in each year in the selected period.</p><p><strong>Free query</strong>. This  page allows you to query the SESAME repository in a direct way by editing yourself the query. After having edited the query and having clicked the \"Start Query\" button, the result of your submission is shown in a table.</p><h5>Implementative details</h5><p>Now let's focus on the implementative details underlying the features provided by the front-end.</p><p>All the queries to the SESAME repository are submitted to the server via HTTP GET requests. The PHP interpreter builds the query string according to the piece of information it has to get from the repository, then it creates an HTTP GET request using the string just built and adds an header specifying the results has to be in the SPARQL Query Results XML format, and it sends it to the SESAME server. After having received the response, the PHP interpreter reads it as a string and creates a SimpleXML element from it, to be able to parse the content of the response.</p><p>All interactions to the SESAME server are based on this mechanism. They aren't used just to query the repository to retrieve the data the user wants to get, but they are performed also to get pieces of information while rendering the options in the forms: this allows the web page to let the user submit always consistent queries, and to prevent him from querying the repository about not stored data.</p>";

function setDiv(i) {
        //alert("ciao");
        document.getElementById("title").innerHTML=title;
        if(i==1)
            document.getElementById("doc").innerHTML=abst;
        if(i==2)
            document.getElementById("doc").innerHTML=keywords;
        if(i==3)
            document.getElementById("doc").innerHTML=intro;
        if(i==4)
            document.getElementById("doc").innerHTML=ontology;
        if(i==5)
            document.getElementById("doc").innerHTML=frontend;
    }


